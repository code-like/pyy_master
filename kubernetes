第二节 容器的介绍
[前情]
操作系统如何管理进程？进程有何特点？这些特点带来什么问题？如何为进程提供独立运行环境？
进程包括系统自带的服务和用户的应用。
第一，这些进程可以相互看到、相互通信；>> 高级权限的进程可以攻击其他进程
第二，它们使用的是同一个文件系统，可以对同一个文件进行读写操作；>>具有高级权限的进程可能会将其他进程的数据删除掉，破坏掉其他进程的正常运行;
                                                            进程与进程之间的依赖可能会存在冲突
第三，这些进程会使用相同的系统资源。>>可能会存在资源抢占的问题，当一个应用需要消耗大量 CPU 和内存资源的时候，就可能会破坏其他应用的正常运行
针对不同进程使用同一个文件系统 >>> linux&unix 操作系统通过chroot达到视图隔离，进程具备独立文件系统
namespaces 实现进程在资源视图上的隔离
cgroups 限制资源使用率，限制CPU使用和内存量

什么是容器？
容器就是一个视图隔离，资源可限制，独立的文件系统的进程集合。不需要具备内核相关的代码和工具，只需二进制文件，配置文件和依赖。

什么是镜像？如何构建？
容器运行时所需要的所有的文件集合称之为容器镜像。采用dockerfile 构建镜像。构建过程中文件系统的变化称为changeset。

changeset的分层和复用带来什么优势？
提高分发效率 > 镜像拆分可并行下载数据
本地以有存储的数据不做覆盖，只需下载本地没有的数据
镜像数据共享，节省了磁盘空间。这就是复用的能力。

实例：dockerfile 创建：构建 golang 应用
from golang:1.12-alpine #基于该版本镜像
workdir /go/src/app #创建文件路径
copy . . #复制本地文件到/go/src/app，将宿主机上的文件拷贝到容器镜像内
run go get -d -v #获取独立系统
run go install -v #创建安装应用
cmd <"app"> #运行应用程序
创建完成dockerfile , 则可通过 docker build 构建应用。
推到镜像仓库：docker push

如何运行容器？
从镜像仓库下载镜像
docker images 查看本地镜像
docker run 运行镜像。可多次运行得到多个容器。一个镜像就是一个模板，一个容器就是一个运行实例，因此镜像就具有了一次构建、到处运行的特点。

容器的生命周期？
docker run : 选择一个镜像提供独立的文件系统，指定相应的initial进程。 initial 退出， 容器退出。 inital 启动 ，容器启动。
注：initial 携带很多运维子进程（docker exec产生）， 这些子进程会随着initial的退出而退出，防止资源泄漏。

什么是数据卷？数据卷的特点是什么？如何管理数据卷？
将容器产生的重要数据持久化，并保存在指定目录，这个目录就叫数据卷。
数据卷的生命周期独立于容器的生命周期。帮助容器进行持久化。也就是说，数据卷挂载到容器内，容器可以将数据写入相应目录，一旦容器退出，不会导致数据丢失。
管理数据卷：1.bind方式将宿主机的目录直接挂载到容器内。（缺点：依赖宿主机，需管理宿主机） 2.目录管理交给运行引擎

容器项目如何架构？
moby容器引擎架构。使用moby容器管理引擎，moby daemon对上提供关于容器、镜像、网络、volume管理。moby daemon依赖的重要组件是
containerd(容器运行的管理引擎，独立于moby daemon) 

为什么要使用containerd作为守护进程？
首先，containerd （底层有 containerd shim模块） 需要管理容器生命周期，而容器可能是由不同的容器运行时所创建出来的，因此需要提供一个灵活的插件化管理。
而 shim 就是针对于不同的容器运行时所开发的，这样就能够从 containerd 中脱离出来，通过插件的形式进行管理。

其次，因为 shim 插件化的实现，使其能够被 containerd 动态接管。如果不具备这样的能力，当 moby daemon 或者 containerd daemon 
意外退出的时候，容器就没人管理了，那么它也会随之消失、退出，这样就会影响到应用的运行。

最后，因为随时可能会对 moby 或者 containerd 进行升级，如果不提供 shim 机制，那么就无法做到原地升级，也无法做到不影响业务的升级，
因此 containerd shim 非常重要，它实现了动态接管的能力。

容器和VM的差别是什么？
VM 利用 Hypervisor 虚拟化技术来模拟 CPU、内存等硬件资源，这样就可以在宿主机上建立一个 Guest OS，这是常说的安装一个虚拟机。
Guest OS 都有一个独立的内核，比如 Ubuntu、CentOS 甚至是 Windows 等，在这样的 Guest OS 之下，每个应用都是相互独立的。
VM 可以提供一个更好的隔离效果。而代价就是需要把一部分的计算资源交给虚拟化，这样就很难充分利用现有的计算资源，并且每个Guest OS 
都需要占用大量的磁盘空间，比如 Windows 操作系统的安装需要 10~30G 的磁盘空间，Ubuntu 也需要 5~6G，同时这样的方式启动很慢。
正是因为虚拟机技术的缺点，催生出了容器技术。

容器是针对于进程而言的，因此无需 Guest OS，只需要一个独立的文件系统提供其所需要文件集合即可。所有的文件隔离都是进程级别的，
因此启动时间快于 VM，并且所需的磁盘空间也小于 VM。当然了，进程级别的隔离并没有想象中的那么好，隔离效果相比 VM 要差很多。

总结：
容器是和系统其它部分隔离开的进程集合。系统的其它部分包含了文件系统、网络资源和进程。
镜像就是容器运行的所有文件的集合，特点：一次创建，到处运行。
容器生命周期=initial进程生命周期
容器与VM的区别：容器隔离效果比VM差，VM难以充分利用计算资源，占用磁盘空间大，启动缓慢，容器正好弥补了这些缺点，也向着强隔离方向发展。













